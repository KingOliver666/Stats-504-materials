# Support points and quantization

For reference, the method used in this notebook was originally proposed in this paper: https://arxiv.org/pdf/1609.01811.pdf

You don't need to review this paper, there should be sufficient background provided in this notebook, in the 'multivariate' methods document, and in the lectures. 

```{r}
library(ggplot2)
source("read.R")
```

```{r}
# Equation 22 in Mak et al.
update_support = function(X, Y) {
    p = dim(Y)[1]
    N = dim(Y)[2]
    n = dim(X)[2]
    XX = array(0, c(p, n))

    for (i in 1:n) {
        Dx = X[,i] - X
        DxN = sqrt(colSums(Dx^2))
        DxN[i] = Inf
        Dy = X[,i] - Y
        DyN = sqrt(colSums(Dy^2))
        q = sum(1 / DyN)
        XX[,i] = (Dx %*% (1/DxN)) * (N / n)
        XX[,i] = XX[,i] + Y %*% (1/DyN)
        XX[,i] = XX[,i] / q
    }

    return(XX)
}
```

```{r}
# Calculate N support points for the data in Y.  The points
# are stored in the columns of Y.
support = function(Y, N, maxiter=1000) {

    p = dim(Y)[1]
    n = dim(Y)[2]
    X = array(rnorm(N*p), c(p, N))

    for (i in 1:maxiter) {
        X1 = update_support(X, Y)
        ee = norm(X1 - X)
        X = X1
        if (ee < 1e-8) {
            break
        }
    }

    return(X)
}
```

Plot support points for temperature and salinity separately.

```{r}
for (j in 1:2) {

    if (j == 1) {
        xdat = temp
        ylab = "Temperature"
    } else {
        xdat = psal
        ylab = "Salinity"
    }

    # Make plots with different numbers of support points.
    for (npt in c(1, 2, 5)) {
        cat(sprintf("npt=%d\n", npt))
        X = support(xdat, npt, maxiter=50)

        # Put the support points in long form for plotting
        da = data.frame(x=array(X), g=kronecker(1:npt, array(1, 100)),
                        pressure=kronecker(array(1, npt), pressure))

        plt = ggplot(aes(x=pressure, y=x, group=g), data=da) + geom_line()
        plt = plt + labs(x="Pressure", y=ylab) + ggtitle(sprintf("%d support points", npt))
        print(plt)
    }
}
```
To understand the joint variation of temperature and salinity, concatenate these two measures and calculate support points.

```{r}
tempz = (temp - mean(temp)) / sd(temp)
psalz = (psal - mean(psal)) / sd(psal)
tp = rbind(tempz, psalz)
for (npt in c(3, 5)) {
    S = support(tp, npt, maxiter=50)

    # Put the support points in long form for plotting
    ix = kronecker(1:(2*npt), array(1, 100))
    spt = as.factor(1 + (ix %% npt))
    mea = c("Temp", "Psal")[1 + floor((ix - 1) / npt)]
    grp = c(sprintf("Temp%d", 1:npt), sprintf("Psal%d", 1:npt))[ix]
    da = data.frame(x=array(S), grp=grp, spt=spt, mea=mea,
                    pressure=kronecker(array(1, 2*npt), pressure))

    plt = ggplot(aes(x=pressure, y=x, group=grp, color=spt, lty=mea), data=da) + geom_line()
    plt = plt + labs(x="Pressure", y=ylab) + ggtitle(sprintf("%d support points", npt))
    print(plt)
}
```

# Stability analysis of support point estimation

Below we calculate 'npt' support points 'nrep' times, each time using a random subsample of 10,000 profiles.  Set the variable 'x' to either 'temp' or 'psal' to conduct this stability analysis on the temperature or salinity data.

```{r}
npt = 10
nrep = 5
x = temp
S = list()
n = dim(x)[2]
for (k in 1:nrep) {
    ii = sample(1:n, 10000, replace=F)
    X = support(x[, ii], npt, maxiter=50)
    S[[k]] = X
}
```

The following function calculates the average distance between a column of X and a column of Y.

```{r}
ediff = function(X, Y) {
    if (dim(X)[2] > dim(Y)[2]) {
        Z = X
        X = Y
        Y = Z
    }
    d = 0.0
    for (j in 1:dim(X)[2]) {
        u = (Y - X[, j])^2
        d = d + sum(sqrt(apply(u, 2, sum)))
    }
    d = d / (dim(X)[2] + dim(Y)[2])
    return(d)
}
```

The following function calculates the (sample) energy distance between the columns of X and Y.

```{r}
energy_distance = function(X, Y) {
  return(2*ediff(X, Y) - ediff(X, X) - ediff(Y, Y))
}
```